#%%
import os
import pickle
import dill
import torch
import torch.nn as nn
from tqdm import tqdm
import numpy as np
from sklearn.model_selection import StratifiedKFold
from torch_geometric.data import Data

# Set a random seed for reproducibility
SEED = 42
np.random.seed(SEED)
torch.manual_seed(SEED)

#%%
def extend_labels(data_idx, n_win):
    """
    Extends subject-level indices to window-level indices.
    If a subject `i` has `n_win` windows, and `i` is in `data_idx`,
    then indices `i*n_win` to `(i+1)*n_win - 1` are included.
    
    Args:
        data_idx (np.ndarray): Array of subject indices.
        n_win (int): Number of windows per subject.
        
    Returns:
        np.ndarray: Array of extended (window-level) indices.
    """
    ex_data_idx = []
    for i in range(len(data_idx)):
        idx = data_idx[i]
        st = idx * n_win
        en = st + n_win
        ex_data_idx.extend(np.linspace(st, en - 1, n_win, dtype=int))
    return np.array(ex_data_idx)

def get_fold_indices(labels):
    """
    Generates stratified 5-fold cross-validation indices for outer and inner loops.
    This creates a nested cross-validation setup (e.g., for hyperparameter tuning).
    
    Args:
        labels (np.ndarray): Array of subject-level labels.
        
    Returns:
        dict: A dictionary containing train, test, and validation indices for each fold.
              Structure: {'outerX_innerY': {'train': [...], 'test': [...], 'val': [...]}}
    """
    fold_idx = dict()
    labels_out = labels

    # Outer K-fold for train/test split
    skf_out = StratifiedKFold(n_splits=5, shuffle=True, random_state=SEED)
    for i, (train_idx_out, test_idx_out) in enumerate(skf_out.split(np.zeros(len(labels_out)), labels_out)):
        labels_in = labels_out[train_idx_out]
        
        # Inner K-fold for train/validation split within the outer training set
        skf_in = StratifiedKFold(n_splits=5, shuffle=True, random_state=SEED)
        for j, (train_idx_in, val_idx_in) in enumerate(skf_in.split(np.zeros(len(labels_in)), labels_in)):
            train_idx = train_idx_out[train_idx_in]
            val_idx = train_idx_out[val_idx_in]
            test_idx = test_idx_out # Test set remains the same for inner folds of a given outer fold
            
            # Store indices for the current fold
            fold_idx[f'outer{i+1}_inner{j+1}'] = {
                'train': train_idx,
                'test': test_idx,
                'val': val_idx
            }
           
    return fold_idx

def load_data():
    """
    Loads the processed dynamic graph data (node features, adjacency matrices, labels)
    generated by step1_compute_ldw.py.
    
    Returns:
        tuple: (data, adj, labels)
            data (list): List of node features (correlation matrices) for each subject and window.
            adj (list): List of adjacency matrices for each subject and window.
            labels (np.ndarray): Subject-level labels.
    """
    with open('./data/ldw_data/LDW_abide_data.pkl', 'rb') as f:
        f = dill.load(f) # Using dill for potentially complex objects
    data = f['node_feat']
    adj = f['adj_mat']
    labels = f['labels']
    return data, adj, labels

def get_fold_data(data, adj, seqlen, label, indices, name, i, j):
    """
    Retrieves data, adjacency matrices, sequence lengths, and labels for a specific fold
    (train, test, or validation set) based on the generated indices.
    
    Args:
        data (list): All node features data.
        adj (list): All adjacency matrices data.
        seqlen (list): All sequence lengths.
        label (np.ndarray): All labels.
        indices (dict): Dictionary of fold indices from `get_fold_indices`.
        name (str): 'train', 'test', or 'val'.
        i (int): Outer fold index.
        j (int): Inner fold index.
        
    Returns:
        tuple: (Corr, Adj, SeqLen, Label)
            Corr (list): Node features for the specified fold.
            Adj (list): Adjacency matrices for the specified fold.
            SeqLen (list): Sequence lengths for the specified fold.
            Label (np.ndarray): Labels for the specified fold.
    """
    current_indices = indices[f'outer{i}_inner{j}'][name]
    data_fold = [data[k] for k in current_indices]
    adj_fold = [adj[k] for k in current_indices]
    seqlen_fold = [seqlen[k] for k in current_indices]
    label_fold = [label[k] for k in current_indices]
    return data_fold, adj_fold, seqlen_fold, label_fold

def pad_graph_seq(data):
    """
    Pads sequences of graph data (node features or adjacency matrices) to the same length
    within a batch, preparing them for recurrent processing.
    
    Args:
        data (list): A list of lists, where each inner list contains
                     the sequence of node features/adjacency matrices for a subject.
                     Each element in the inner list is a numpy array.
                     
    Returns:
        tuple: (sequences_padded, seqlengths)
            sequences_padded (torch.Tensor): Padded sequences (batch_first=True).
            seqlengths (torch.LongTensor): Original sequence lengths for each subject.
    """
    # Convert inner numpy arrays to torch tensors
    sequences = [torch.tensor(np.array(i), dtype=torch.float32) for i in data]
    # Get original sequence lengths
    seqlengths = torch.LongTensor([len(x) for x in sequences])
    # Pad sequences to the maximum length in the batch
    sequences_padded = nn.utils.rnn.pad_sequence(sequences, batch_first=True)
    return sequences_padded, seqlengths

def convert2graphs(Corr, Adj, SeqLen, Label):
    """
    Converts lists of correlation matrices, adjacency matrices, sequence lengths,
    and labels into a 2D NumPy array of `torch_geometric.data.Data` objects.
    Each `Data` object represents a single graph (a window from a subject's sequence).
    
    Args:
        Corr (list): List of correlation matrices (node features).
        Adj (list): List of adjacency matrices.
        SeqLen (list): List of sequence lengths for each subject.
        Label (np.ndarray): Subject-level labels.
        
    Returns:
        np.ndarray: A 2D NumPy array (subjects x windows) of `torch_geometric.data.Data` objects.
    """
    n_sub = len(Corr)
    # Assuming all subjects have the same max number of windows after padding
    n_win = Corr[0].shape[0] 
    num_classes = len(set(Label)) # Number of unique classes

    # Initiate empty container for graphs
    Graph = np.empty([n_sub, n_win], dtype=object)

    for i in tqdm(range(n_sub), desc="Converting to PyG Graphs"):
        for j in range(n_win):
            corr = Corr[i][j] # Node features for current window
            adj = Adj[i][j]   # Adjacency matrix for current window
            seqlen = SeqLen[i] # Original sequence length for current subject
            label = Label[i]   # Label for current subject
            
            # Determine if this graph is a padding graph (all zeros in adjacency)
            # This check might be too strict if a valid graph can have all-zero rows/columns.
            # A more robust check for padding would be based on the original sequence length.
            padding = (torch.sum(adj) == 0) # Check if the sum of adjacency matrix is zero

            # Get non-zero elements of adj matrix to form edge_index
            nodeFeat = corr.float() # Convert node features to float tensor
            num_nodes = nodeFeat.shape[0]
            num_node_features = nodeFeat.shape[1]
            
            # Find indices of non-zero elements (edges)
            index = torch.nonzero(adj)
            # Get values of these non-zero elements (edge attributes, if any)
            values = adj[index[:, 0], index[:, 1]]

            # Format edge_index for PyTorch Geometric (2xNumEdges)
            edgeIndex = index.T.long()
            # Edge attributes (if values are used as attributes)
            edgeAttr = values.unsqueeze(-1).float() 
            
            adj_node = adj.float() # Adjacency matrix as a tensor
            labeL = torch.tensor(label).long() # Label as a long tensor

            # Create a PyTorch Geometric Data object
            graph = Data(x=nodeFeat, edge_index=edgeIndex, edge_attr=edgeAttr, adj=adj_node, y=labeL, 
                         num_nodes=num_nodes, num_node_features=num_node_features, num_classes=num_classes,
                         pad=padding, # Indicates if this is a padding graph
                         last=(j + 1 == seqlen)) # Indicates if this is the last valid graph in the sequence
            
            Graph[i, j] = graph # Store the created graph object

    return Graph

# Main execution block
if __name__ == "__main__":
    saveTo = './data/folds_data/'  
    os.makedirs(saveTo, exist_ok=True) # Create directory for saving fold data

    print('Loading data from step1_compute_ldw.py...')
    all_data, all_adj, labels = load_data()
    print('Data loaded.')

    print('Padding graph sequences...')
    # Pad node features and adjacency matrices
    all_data_padded, seqlengths = pad_graph_seq(all_data)
    all_adj_padded, _ = pad_graph_seq(all_adj) # Adjacency matrices also padded
    print('Padding complete.')

    print('Generating fold indices for cross-validation...')
    fold_indices = get_fold_indices(labels)
    print('Fold indices generated.')

    # Iterate through outer and inner cross-validation folds
    for i in range(1, 6): # Outer folds (1 to 5)
        for j in range(1, 6): # Inner folds (1 to 5)

            print(f'Processing outer{i}_inner{j}...')
            
            # Get training data for the current fold
            Corr, Adj, SeqLen, Label = get_fold_data(all_data_padded, all_adj_padded, seqlengths, labels, fold_indices, 'train', i, j)
            train_graphs = convert2graphs(Corr, Adj, SeqLen, Label)

            # Get testing data for the current fold
            Corr, Adj, SeqLen, Label = get_fold_data(all_data_padded, all_adj_padded, seqlengths, labels, fold_indices, 'test', i, j)
            test_graphs = convert2graphs(Corr, Adj, SeqLen, Label)

            # Get validation data for the current fold
            Corr, Adj, SeqLen, Label = get_fold_data(all_data_padded, all_adj_padded, seqlengths, labels, fold_indices, 'val', i, j)
            val_graphs = convert2graphs(Corr, Adj, SeqLen, Label)

            # Store all graph sets for the current fold in a dictionary
            graphs = {
                'train_graphs': train_graphs,
                'test_graphs': test_graphs,
                'val_graphs': val_graphs
            }

            print('Saving graphs...')     
            # Save the graphs for the current fold
            with open(os.path.join(saveTo, f'graphs_outer{i}_inner{j}.pkl'), 'wb') as f:
                torch.save(graphs, f) # Use torch.save for PyTorch objects
                f.close()
            print(f'Graphs for outer{i}_inner{j} saved successfully.')

